<!DOCTYPE html>
 <html lang="en"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title data-react-helmet="true">Realtime with Rails </title><meta data-react-helmet="true" name="description" content="Server sent events and Postgres notify/listen"/><link href="https://fonts.googleapis.com/css?family=Raleway:300,400,700" rel="stylesheet"/><link rel="author" href="https://plus.google.com/103412889445491341044"/><script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyB10DGDrJaB7IauMg99tM97DUH9QC4rcO8"></script><style>.me{border-bottom:1px solid #eee;text-align:center;margin-bottom:40px}.me__profile{padding:10px}.me__profile__name{font-weight:700;color:#222;margin-top:10px;margin-bottom:0}.me__profile__desc{font-size:20px;font-weight:200;color:#aaa;margin-top:20px}.me__photo{animation:bounce 1s normal;margin-right:20px}.me__photo img{margin:0}.me__photo img:hover{animation:bounce 1s infinite}.me__photo__avatar{display:inline-block;width:110px;height:110px;border-radius:50%}.me__separator{width:60%;border-top:1px solid #eee}.me p a{font-weight:500}.me p{color:#aaa;font-weight:200;margin:0;padding:5px}.me p:last-child{margin-bottom:15px}@keyframes bounce{0%,20%,53%,80%,to{animation-timing-function:cubic-bezier(.215,.61,.355,1);transform:translateZ(0)}40%,43%{animation-timing-function:cubic-bezier(.755,.05,.855,.06);transform:translate3d(0,-30px,0)}70%{animation-timing-function:cubic-bezier(.755,.05,.855,.06);transform:translate3d(0,-15px,0)}90%{transform:translate3d(0,-4px,0)}}.markdown img{width:100%}.markdown p,li,ul{color:#666;-webkit-font-smoothing:antialiased;text-rendering:optimizeLegibility;font-size:18px;line-height:1.4em;margin-top:20px;margin-bottom:20px}.markdown pre{display:block;background:#3f3f3f;color:#dcdcdc;overflow-y:hidden;margin-top:30px;margin-bottom:30px}.markdown pre code{background:none;border:none;border-radius:3px;display:inline-block;overflow:inherit;padding:1.58333rem;white-space:inherit;word-wrap:normal}code{border-radius:3px;white-space:pre;white-space:pre-wrap;white-space:pre-line;white-space:-pre-wrap;white-space:-o-pre-wrap;white-space:-moz-pre-wrap;white-space:-hp-pre-wrap;word-wrap:break-word;background:#e5e5e5;border:1px solid #ccc;display:inline;font-family:Inconsolata,monospace,serif;max-width:100%;overflow:auto;padding:0 .1625rem}.clojure .hljs-attribute,.css .hljs-class,.css .hljs-id,.hljs-keyword,.hljs-request,.hljs-status,.hljs-tag,.lisp .hljs-title,.nginx .hljs-title{color:#e3ceab}.django .hljs-filter .hljs-argument,.django .hljs-template_tag,.django .hljs-variable{color:#dcdcdc}.hljs-date,.hljs-number{color:#8cd0d3}.apache .hljs-sqbracket,.dos .hljs-envvar,.dos .hljs-stream,.hljs-variable{color:#efdcbc}.diff .hljs-change,.dos .hljs-flow,.hljs-literal,.python .exception,.python .hljs-built_in,.tex .hljs-special{color:#efefaf}.diff .hljs-chunk,.hljs-subst{color:#8f8f8f}.apache .hljs-tag,.diff .hljs-header,.dos .hljs-keyword,.haskell .hljs-type,.hljs-prompt,.hljs-title,.nginx .hljs-built_in,.python .hljs-decorator,.ruby .hljs-class .hljs-parent,.tex .hljs-command{color:#efef8f}.dos .hljs-winutils,.ruby .hljs-string,.ruby .hljs-symbol,.ruby .hljs-symbol .hljs-string{color:#dca3a3}.apache .hljs-cbracket,.coffeescript .hljs-attribute,.css .hljs-rules .hljs-value,.diff .hljs-deletion,.hljs-attr_selector,.hljs-built_in,.hljs-javadoc,.hljs-pragma,.hljs-preprocessor,.hljs-pseudo,.hljs-string,.hljs-tag .hljs-value,.smalltalk .hljs-array,.smalltalk .hljs-class,.smalltalk .hljs-localvars,.sql .hljs-aggregate,.tex .hljs-formula{color:#cc9393}.diff .hljs-addition,.hljs-comment,.hljs-doctype,.hljs-pi,.hljs-shebang,.hljs-template_comment,.java .hljs-annotation{color:#7f9f7f}.coffeescript .javascript,.javascript .xml,.tex .hljs-formula,.xml .css,.xml .hljs-cdata,.xml .javascript,.xml .vbscript{opacity:.5}.post__title{text-align:center;font-weight:200;color:#222;margin-top:0}p.post__date{font-size:14px;text-transform:uppercase;color:#aaa;text-align:center;margin:0 auto;margin-bottom:40px}body{margin:0;border-top:8px solid #d64292;font-family:Raleway,sans-serif}.wrapper{padding:60px 40px 0;max-width:700px;margin:0 auto}.love{font-weight:200}.load-more,.love{padding-bottom:80px;padding-top:60px;color:#aaa;text-align:center;margin:0 auto}.load-more{font-size:16px;font-weight:500}.load-more button{font-size:16px;font-weight:700;color:#d64292;background:none;border:none;margin:0;padding:0;cursor:pointer}.load-more button:hover{text-decoration:underline}.purple,a{color:#d64292;text-decoration:none}hr{margin-top:40px;margin-bottom:40px;width:80%;border:1px solid #eee}.post-list{padding:10px}.post-list__item{text-decoration:none;display:block;padding-left:20px;border-left:4px solid #aaa;min-height:100px;margin-bottom:80px;transition:all .4s ease-out}.post-list__item-enter{opacity:.01}.post-list__item-enter-active{opacity:1}.post-list__item:last-child{margin-bottom:0}.post-list__item:hover{border-left:4px solid #d64292}.post-list__item__header{margin-top:26px;display:-ms-flexbox;display:flex}.post-list__item__header__title{-ms-flex:4;flex:4;font-size:20px;color:#222;margin-top:0;margin-bottom:8px}.post-list__item__header__date{-ms-flex:1;flex:1;color:#aaa;text-align:right}.post-list__item__desc{color:#aaa;font-size:18px;margin-top:0}.talk-list{max-width:600px;margin:0 auto}.talk-list__talk{border-radius:2px;margin-top:40px;display:-ms-flexbox;display:flex;box-shadow:0 1px 3px rgba(0,0,0,.12),0 1px 2px rgba(0,0,0,.24);transition:all .3s cubic-bezier(.25,.8,.25,1)}.talk-list__talk:hover{box-shadow:0 14px 28px rgba(0,0,0,.25),0 10px 10px rgba(0,0,0,.22)}.talk-list__talk__map{-ms-flex:1;flex:1}.talk-list__talk__content{padding:20px;-ms-flex:3;flex:3}.talk-list__talk__content p{margin-top:0;margin-bottom:15px}.talk-list__talk__content__name{font-weight:200;font-size:24px}.talk-list__talk__content__name--cancelled{text-decoration:line-through}.cancelled{font-weight:200;font-size:24px;color:red;text-decoration:none}.talk-list__talk__content__event{font-weight:200;color:#222;font-size:18px}.light{color:#aaa}</style></head><body class="landing-page"><div id="react-mount"><div style="max-width:960px;margin-left:auto;margin-right:auto;" data-reactroot="" data-reactid="1" data-react-checksum="-1471158279"><div class="wrapper markdown" data-reactid="2"><!-- react-empty: 3 --><h1 class="post__title" data-reactid="4">Realtime with Rails </h1><p class="post__date" data-reactid="5">August 29, 2015</p><div data-reactid="6"><p>I spent the last few days trying to find a way to build a real-time feel to my <a href="http://teamboardapp.com">Teamboard</a> project. I was mainly looking towards websocket solutions until I stumbled upon a Rails 4 new addition – <a href="http://api.rubyonrails.org/classes/ActionController/Live/SSE.html">ActionController::Live::SSE</a> which lets you stream data to a client.</p>
<p>Teamboard is a project of mine where users can create white boards, add and share notes with their team. I wanted the users to be able to see the changes made to the board in real time. My solution is inspired from a couple blogs mainly <a href="http://tenderlovemaking.com/2012/07/30/is-it-live.html">TenderLove’s Is It Live?</a> and <a href="http://ngauthier.com">ngauthier.com</a>.</p>
<p>First, I changed the default rails server (WebRick) to Puma. Add the Puma gem to your Gemfile and check out the heroku puma docs to learn how to set it up</p>
<p><code>ruby gem 'puma'</code></p>
<p>Then I created a new route for my board controller and called my new controller method “Events”. Clients can then connect to /api/board/:id/events through EventSource and listen to changes in the board.</p>
<pre><code class="language-ruby"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">events</span></span>
  @board = current_user.boards.find(params[<span class="hljs-symbol">:id</span>])
  response.headers[<span class="hljs-string">'Content-Type'</span>] = <span class="hljs-string">'text/event-stream'</span>
  sse = SSE.new(response.stream, <span class="hljs-symbol">event:</span> <span class="hljs-string">"changed"</span>)
  @board.on_board_change <span class="hljs-keyword">do</span> <span class="hljs-params">|change|</span>
    change = JSON.parse(change)
    sse.write({<span class="hljs-symbol">change:</span> change})
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>As you can see, we’re waiting for on_board_change to return a change. This would usually be a blocking operation but since we’re using Puma we will be able to serve other requests concurrently. Lets check out the on_board_change method which is in the Board model</p>
<pre><code class="language-ruby">after_save <span class="hljs-symbol">:notify_board_change</span> after_create <span class="hljs-symbol">:notify_board_change</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">notify_board_change</span><span class="hljs-params">(change = {<span class="hljs-symbol">:board</span> =&gt; <span class="hljs-literal">true</span>})</span></span>
  ActiveRecord::Base.connection_pool.with_connection <span class="hljs-keyword">do</span> <span class="hljs-params">|connection|</span>
    conn = connection.instance_variable_get(<span class="hljs-symbol">:</span>@connection)
    conn.async_exec <span class="hljs-string">"NOTIFY <span class="hljs-subst">#{channel}</span>, '<span class="hljs-subst">#{change.to_json}</span>'"</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">on_board_change</span></span>
 ActiveRecord::Base.connection_pool.with_connection <span class="hljs-keyword">do</span> <span class="hljs-params">|connection|</span>
   conn = connection.instance_variable_get(<span class="hljs-symbol">:</span>@connection)
   <span class="hljs-keyword">begin</span>
     $redis.lpush(<span class="hljs-string">"opened_board_ids"</span>, <span class="hljs-keyword">self</span>.id)
     conn.async_exec <span class="hljs-string">"LISTEN <span class="hljs-subst">#{channel}</span>"</span>
     logger.info <span class="hljs-string">'Starting Listening on channel <span class="hljs-subst">#{channel}</span>'</span>
     loop <span class="hljs-keyword">do</span> conn.wait_for_notify <span class="hljs-keyword">do</span> <span class="hljs-params">|event, pid, change|</span>
       <span class="hljs-keyword">yield</span> change
     <span class="hljs-keyword">end</span>
   <span class="hljs-keyword">end</span>
   <span class="hljs-keyword">ensure</span>
     conn.async_exec <span class="hljs-string">"UNLISTEN <span class="hljs-subst">#{channel}</span>"</span>
     $redis.lrem(<span class="hljs-string">"opened_board_ids"</span>, -<span class="hljs-number">1</span>, <span class="hljs-keyword">self</span>.id)
     logger.info <span class="hljs-string">'Finished Listening on channel <span class="hljs-subst">#{channel}</span>'</span>
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

private
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">channel</span></span>
  <span class="hljs-string">"boards_<span class="hljs-subst">#{id}</span>"</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>A lot of things are going on here. I’m choosing to use postgres’s Listen/Notify which is similar to redis pub/sub. Everytime a client connects to /events, on_board_change method is called and we wait for a notify on the channel. When the board is changed, the notify_board_change method is called and we return this change to the controller. I kept every board we listen to in redis, you’ll see why later. I chose to name my channels boards_:id to keep things simple later. I then use the after_save callback to NOTIFY these channels. Each Board has many BoardItems. I added callbacks to BoardItem.rb too. They call the same method as the board does as you can see here</p>
<pre><code class="language-ruby">after_create <span class="hljs-symbol">:notify_board_change</span>
after_destroy <span class="hljs-symbol">:notify_board_change</span>
after_save <span class="hljs-symbol">:notify_board_change</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">notify_board_change</span></span>
  <span class="hljs-keyword">self</span>.board.notify_board_change({<span class="hljs-symbol">:board_item</span> =&gt; <span class="hljs-keyword">self</span>.id})
<span class="hljs-keyword">end</span>
</code></pre>
<p>Client side now. I’m using AngularJS in my project, here’s how i connect to my API using EventSource.</p>
<pre><code class="language-javascript">$timeout( () -&gt; source = new EventSource('/api/boards/' + $routeParams.board_id + '/events')
$scope.$on '$destroy', () -&gt; source.close()

source.addEventListener 'changed', (e) -&gt;
  data = JSON.parse(e.data).change
  if data.board_item
    $scope.$broadcast('update-'+data.board_item)
  else if data.hb # DO NOTHING
  else ... ```

Now everything works great but I found out a strange issue with the Rails Live Streaming. It seems SSE never realises when the connection is over with the client (https://github.com/rails/rails/issues/10989). This means a refresh, closing the browser and navigating away doesn't kill the thread that is waiting for changes. This is bad and makes Puma crash pretty quickly on a small number of workers and threads. There doesnt seem to be a nice way to fix this for now but I coded I workaround that is often proposed for this issue, that is a heartbeat thread, that checks if the connection is open every x seconds. I placed this in the puma initializer file puma.rb

```ruby
def create_heartbeat
  heartbeat = Thread.new do begin hb = {"hb": true}
  ActiveRecord::Base.connection_pool.with_connection do |connection|
    conn = connection.instance_variable_get(:@connection)
    loop do
      opened_boards = $redis.lrange("opened_board_ids", 0, -1)
      opened_boards.each do |board_id|
        conn.async_exec "NOTIFY boards_#{board_id}, '#{hb.to_json}'"
      end
      sleep 20.seconds
    end
  end
  ensure
  end
end
</code></pre>
<p>The amount of time to sleep between heartbeats is kind of a tradeoff. The longer it is, the longer a thread will be stuck before we kill it and reuse it but you probably dont want to set that number too low either. Since I kept the boards that were listened to in redis, I heartbeat all those channels and remove them from redis when they are killed</p>
<p>Hope this will help some of you. Sever Side Events are pretty cool but I am wondering if I should try the same with WebSockets until they fix the issue I linked above!</p>
<p>You can find me on Twitter <a href="https://twitter.com/__xuorig__">@__xuorig__</a> or <a href="http://github.com/xuorig">Github</a></p>
</div><p style="text-align:center;font-weight:bold;margin-top:30px;" data-reactid="7"><!-- react-text: 8 -->Go back to <!-- /react-text --><a href="/" data-reactid="9">Recent Posts</a><!-- react-text: 10 --> ✍️<!-- /react-text --></p><hr data-reactid="11"/><div style="margin-bottom:30px;" data-reactid="12"><h6 data-reactid="13">READ THIS NEXT:</h6><h3 data-reactid="14"><a href="/2016/implementing-the-relay-spec-for-a-graphql-server/" data-reactid="15">Implementing the Relay spec in a GraphQL server</a></h3><p data-reactid="16">





I’ve seen some confusion on Relay and GraphQL lately. GraphQL is so often used with Relay that I think sometimes we forget what a GraphQL server is, and what Relay adds on top of it. The goal of...</p></div><section class="disqus" data-reactid="17"><div id="disqus_thread" data-reactid="18"></div><script type="text/javascript" data-reactid="19"></script></section></div><span style="display:block;clear:both;" data-reactid="20"> </span></div></div><script src="/bundle.js?t=1478107512649"></script></body></html>