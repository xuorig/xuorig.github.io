<!DOCTYPE html>
 <html lang="en"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title data-react-helmet="true">Caching GraphQL queries with GraphQL-ruby and Rails</title><meta data-react-helmet="true" name="description" content="How to avoid parsing GraphQL queries everytime and how to cache GraphQL documents"/><link href="https://fonts.googleapis.com/css?family=Raleway:300,400,700" rel="stylesheet"/><link rel="author" href="https://plus.google.com/103412889445491341044"/><script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyB10DGDrJaB7IauMg99tM97DUH9QC4rcO8"></script><style>.me{border-bottom:1px solid #eee;text-align:center;margin-bottom:40px}.me__profile{padding:10px}.me__profile__name{font-weight:700;color:#222;margin-top:10px;margin-bottom:0}.me__profile__desc{font-size:20px;font-weight:200;color:#aaa;margin-top:20px}.me__photo{animation:bounce 1s normal;margin-right:20px}.me__photo img{margin:0}.me__photo img:hover{animation:bounce 1s infinite}.me__photo__avatar{display:inline-block;width:110px;height:110px;border-radius:50%}.me__separator{width:60%;border-top:1px solid #eee}.me p a{font-weight:500}.me p{color:#aaa;font-weight:200;margin:0;padding:5px}.me p:last-child{margin-bottom:15px}@keyframes bounce{0%,20%,53%,80%,to{animation-timing-function:cubic-bezier(.215,.61,.355,1);transform:translateZ(0)}40%,43%{animation-timing-function:cubic-bezier(.755,.05,.855,.06);transform:translate3d(0,-30px,0)}70%{animation-timing-function:cubic-bezier(.755,.05,.855,.06);transform:translate3d(0,-15px,0)}90%{transform:translate3d(0,-4px,0)}}.markdown img{width:100%}.markdown p,li,ul{color:#666;-webkit-font-smoothing:antialiased;text-rendering:optimizeLegibility;font-size:18px;line-height:1.4em;margin-top:20px;margin-bottom:20px}.markdown pre{display:block;background:#3f3f3f;color:#dcdcdc;overflow-y:hidden;margin-top:30px;margin-bottom:30px}.markdown pre code{background:none;border:none;border-radius:3px;display:inline-block;overflow:inherit;padding:1.58333rem;white-space:inherit;word-wrap:normal}code{border-radius:3px;white-space:pre;white-space:pre-wrap;white-space:pre-line;white-space:-pre-wrap;white-space:-o-pre-wrap;white-space:-moz-pre-wrap;white-space:-hp-pre-wrap;word-wrap:break-word;background:#e5e5e5;border:1px solid #ccc;display:inline;font-family:Inconsolata,monospace,serif;max-width:100%;overflow:auto;padding:0 .1625rem}.clojure .hljs-attribute,.css .hljs-class,.css .hljs-id,.hljs-keyword,.hljs-request,.hljs-status,.hljs-tag,.lisp .hljs-title,.nginx .hljs-title{color:#e3ceab}.django .hljs-filter .hljs-argument,.django .hljs-template_tag,.django .hljs-variable{color:#dcdcdc}.hljs-date,.hljs-number{color:#8cd0d3}.apache .hljs-sqbracket,.dos .hljs-envvar,.dos .hljs-stream,.hljs-variable{color:#efdcbc}.diff .hljs-change,.dos .hljs-flow,.hljs-literal,.python .exception,.python .hljs-built_in,.tex .hljs-special{color:#efefaf}.diff .hljs-chunk,.hljs-subst{color:#8f8f8f}.apache .hljs-tag,.diff .hljs-header,.dos .hljs-keyword,.haskell .hljs-type,.hljs-prompt,.hljs-title,.nginx .hljs-built_in,.python .hljs-decorator,.ruby .hljs-class .hljs-parent,.tex .hljs-command{color:#efef8f}.dos .hljs-winutils,.ruby .hljs-string,.ruby .hljs-symbol,.ruby .hljs-symbol .hljs-string{color:#dca3a3}.apache .hljs-cbracket,.coffeescript .hljs-attribute,.css .hljs-rules .hljs-value,.diff .hljs-deletion,.hljs-attr_selector,.hljs-built_in,.hljs-javadoc,.hljs-pragma,.hljs-preprocessor,.hljs-pseudo,.hljs-string,.hljs-tag .hljs-value,.smalltalk .hljs-array,.smalltalk .hljs-class,.smalltalk .hljs-localvars,.sql .hljs-aggregate,.tex .hljs-formula{color:#cc9393}.diff .hljs-addition,.hljs-comment,.hljs-doctype,.hljs-pi,.hljs-shebang,.hljs-template_comment,.java .hljs-annotation{color:#7f9f7f}.coffeescript .javascript,.javascript .xml,.tex .hljs-formula,.xml .css,.xml .hljs-cdata,.xml .javascript,.xml .vbscript{opacity:.5}.post__title{text-align:center;font-weight:200;color:#222;margin-top:0}p.post__date{font-size:14px;text-transform:uppercase;color:#aaa;text-align:center;margin:0 auto;margin-bottom:40px}body{margin:0;border-top:8px solid #d64292;font-family:Raleway,sans-serif}.wrapper{padding:60px 40px 0;max-width:700px;margin:0 auto}.love{font-weight:200}.load-more,.love{padding-bottom:80px;padding-top:60px;color:#aaa;text-align:center;margin:0 auto}.load-more{font-size:16px;font-weight:500}.load-more button{font-size:16px;font-weight:700;color:#d64292;background:none;border:none;margin:0;padding:0;cursor:pointer}.load-more button:hover{text-decoration:underline}.purple,a{color:#d64292;text-decoration:none}hr{margin-top:40px;margin-bottom:40px;width:80%;border:1px solid #eee}.post-list{padding:10px}.post-list__item{text-decoration:none;display:block;padding-left:20px;border-left:4px solid #aaa;min-height:100px;margin-bottom:80px;transition:all .4s ease-out}.post-list__item-enter{opacity:.01}.post-list__item-enter-active{opacity:1}.post-list__item:last-child{margin-bottom:0}.post-list__item:hover{border-left:4px solid #d64292}.post-list__item__header{margin-top:26px;display:-ms-flexbox;display:flex}.post-list__item__header__title{-ms-flex:4;flex:4;font-size:20px;color:#222;margin-top:0;margin-bottom:8px}.post-list__item__header__date{-ms-flex:1;flex:1;color:#aaa;text-align:right}.post-list__item__desc{color:#aaa;font-size:18px;margin-top:0}.talk-list{max-width:600px;margin:0 auto}.talk-list__talk{border-radius:2px;margin-top:40px;display:-ms-flexbox;display:flex;box-shadow:0 1px 3px rgba(0,0,0,.12),0 1px 2px rgba(0,0,0,.24);transition:all .3s cubic-bezier(.25,.8,.25,1)}.talk-list__talk:hover{box-shadow:0 14px 28px rgba(0,0,0,.25),0 10px 10px rgba(0,0,0,.22)}.talk-list__talk__map{-ms-flex:1;flex:1}.talk-list__talk__content{padding:20px;-ms-flex:3;flex:3}.talk-list__talk__content p{margin-top:0;margin-bottom:15px}.talk-list__talk__content__name{font-weight:200;font-size:24px}.talk-list__talk__content__name--cancelled{text-decoration:line-through}.cancelled{font-weight:200;font-size:24px;color:red;text-decoration:none}.talk-list__talk__content__event{font-weight:200;color:#222;font-size:18px}.light{color:#aaa}</style></head><body class="landing-page"><div id="react-mount"><div style="max-width:960px;margin-left:auto;margin-right:auto;" data-reactroot="" data-reactid="1" data-react-checksum="-1763226015"><div class="wrapper markdown" data-reactid="2"><!-- react-empty: 3 --><h1 class="post__title" data-reactid="4">Caching GraphQL queries with GraphQL-ruby and Rails</h1><p class="post__date" data-reactid="5">June 7, 2016</p><div data-reactid="6"><meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@__xuorig__">
<meta name="twitter:creator" content="@__xuorig__">
<meta name="twitter:title" content="Caching GraphQL queries with GraphQL-ruby and Rails">
<meta name="twitter:description" content="How to avoid parsing GraphQL queries everytime and how to cache GraphQL documents">
<meta name="twitter:image" content="https://cloud.githubusercontent.com/assets/2231765/9094460/cb43861e-3b66-11e5-9fbf-71066ff3ab13.png">
<p>When a GraphQL query hits the server, what exactly happens first ? To start the execution, a GraphQL executor must first have a <code>Query Document</code>. Think of it as a query object containing all you need to exectute a query (Operation, Fields, Arguments, etc.).</p>
<p>Of course when we send a query to a GraphQL server, it’s a simple string, not a Document object. The first thing the server has to do is to lex and parse it.</p>
<p>With GraphQL-ruby at least, that step is the slowest one in the chain. Parsing, especially huge queries can be quite slow, and re-parsing the same query twice or more sounds like a huge waste!</p>
<p>What if we could cache the documents right after we’ve parsed the query, and then tell our Schema to take a parsed document instead of a string ?</p>
<p>I’ve worked on a very simple PR with the help of <a href="https://twitter.com/rmosolgo">@rmosolgo</a> a few weeks ago that allows us to do so, let’s take a look at how I implemented a basic caching mechanism for GraphQL queries in Rails.</p>
<h3>Rails.cache</h3>
<p>Let’s take care of some configuration stuff first. I’m using rails 5, to enable cache in development we have to run this:</p>
<pre><code class="language-ruby">  rails <span class="hljs-symbol">dev:</span>cache
</code></pre>
<p>If you’re on Rails &lt; 5, simply enable caching in your <code>development.rb</code> environment.</p>
<h3>Caching documents</h3>
<p>Now the fun stuff! In the <code>GraphQLController</code> we always want to check if we have a document cached for that particular query. If we do we’ll simply use it, if not we’ll parse it using <code>GraphQL.parse(query_string)</code></p>
<p>Here’s how you could implement the caching:</p>
<pre><code class="language-ruby"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create</span></span>
  query_string = params[<span class="hljs-symbol">:query</span>]
  query_variables = params[<span class="hljs-symbol">:variables</span>] <span class="hljs-params">||</span> {}
  document = get_document(query_string)

  result = Schema.execute(
    <span class="hljs-symbol">document:</span> document,
    <span class="hljs-symbol">variables:</span> query_variables
  )

  render <span class="hljs-symbol">json:</span>result
<span class="hljs-keyword">end</span>
</code></pre>
<p>Notice that I never pass the <code>query_string</code> argument to <code>Schema.execute</code>. We always give it the full Document object using the <code>document</code> kwarg.</p>
<p>We get the <code>document</code> by calling <code>get_document</code>. It’s a method I’ve created to handle the caching. Let’s take a look at it:</p>
<pre><code class="language-ruby">  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_document</span><span class="hljs-params">(query_string)</span></span>
    cache_key = Base64.encode64(query_string)
    document = Rails.cache.fetch(cache_key)

    <span class="hljs-keyword">if</span> document
      logger.info <span class="hljs-string">"###############################"</span>
      logger.info <span class="hljs-string">"Got cached document <span class="hljs-subst">#{document}</span>"</span>
      logger.info <span class="hljs-string">"###############################"</span>
    <span class="hljs-keyword">else</span>
      logger.info <span class="hljs-string">"####################################"</span>
      logger.info <span class="hljs-string">"Parsing query string <span class="hljs-subst">#{query_string}</span>"</span>
      logger.info <span class="hljs-string">"Cached at key <span class="hljs-subst">#{cache_key}</span>"</span>
      logger.info <span class="hljs-string">"####################################"</span>

      document = GraphQL.parse(query_string)
      Rails.cache.write(cache_key, document)
    <span class="hljs-keyword">end</span>

    document
  <span class="hljs-keyword">end</span>
</code></pre>
<p>Few things to notice here. To make a slightly nicer key, I Base64 encode the query string before. The rest is pretty straight forward. If we find the document in the cache, we return it straight away. If not, we parse the string using <code>GraphQL.parse</code> and write it in the cache.</p>
<p>Keep in mind a nicer way to do what I have here is simply using <code>Rails.cache.fetch</code> with a block:</p>
<pre><code class="language-ruby">  cache_key = Base64.encode64(query_string)
  Rails.cache.fetch(cache_key) <span class="hljs-keyword">do</span>
    GraphQL.parse(query_string)
  <span class="hljs-keyword">end</span>
</code></pre>
<p>I wanted to have some logs while I tested so I chose the the longer way!</p>
<h3>Results</h3>
<p>When a first query is sent to the server, as expected, we have to parse it:</p>
<p><img src="./nocachelog.png" alt="No Cache Logs"></p>
<p><img src="./nocachetime.png" alt="No Cache Time"></p>
<p>As you can see, it took about <code>0.065</code> to parse, and execute the Query. Can we do much better with caching ? Let’s see. The next request is the exact same query, I simply hit refresh:</p>
<p><img src="./cachedlog.png" alt="Cache Logs"></p>
<p><img src="./cachedtime.png" alt="Cache Time"></p>
<p><code>0.007</code>. Much faster since we did not have to parse the query string this time. Imagine bigger queries!</p>
<p>And that’s it, we have a query cache for our GraphQL server, and it makes it much faster! I was using the <code>memory_store</code> cache in dev here, but nothing stops you from using other key value stores like <code>memcached</code> or <code>redis</code>!</p>
<p>As always, you can find me on Twitter <a href="https://twitter.com/__xuorig__">@__xuorig__</a> or <a href="http://github.com/xuorig">Github</a></p>
</div><p style="text-align:center;font-weight:bold;margin-top:30px;" data-reactid="7"><!-- react-text: 8 -->Go back to <!-- /react-text --><a href="/" data-reactid="9">Recent Posts</a><!-- react-text: 10 --> ✍️<!-- /react-text --></p><hr data-reactid="11"/><div style="margin-bottom:30px;" data-reactid="12"><h6 data-reactid="13">READ THIS NEXT:</h6><h3 data-reactid="14"><a href="/2016/the-mysterious-relay-range-behaviours/" data-reactid="15">RANGE_ADD mutations and the mysterious Relay Range Behaviors</a></h3><p data-reactid="16">





One of the coolest features of Relay is it’s amazing client side cache. When we mutate our data using Mutations, Relay needs to know how to update it’s client cache. The way the Relay team chose...</p></div><section class="disqus" data-reactid="17"><div id="disqus_thread" data-reactid="18"></div><script type="text/javascript" data-reactid="19"></script></section></div><span style="display:block;clear:both;" data-reactid="20"> </span></div></div><script src="/bundle.js?t=1478968123474"></script><script>
            (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
            })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

            ga('create', 'UA-69973242-1', 'auto');
            ga('send', 'pageview');
          </script></body></html>