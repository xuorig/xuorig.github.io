<!DOCTYPE html>
 <html lang="en"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title data-react-helmet="true">Authentication in Relay Applications using Rails and GraphQL</title><meta data-react-helmet="true" name="description" content="Using an Authorization Token to enable authentication in Relay applications using Rails with Devise and GraphQL"/><link href="https://fonts.googleapis.com/css?family=Raleway:300,400,700" rel="stylesheet"/><link rel="author" href="https://plus.google.com/103412889445491341044"/><script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyB10DGDrJaB7IauMg99tM97DUH9QC4rcO8"></script><style>.me{border-bottom:1px solid #eee;text-align:center;margin-bottom:40px}.me__profile{padding:10px}.me__profile__name{font-weight:700;color:#222;margin-top:10px;margin-bottom:0}.me__profile__desc{font-size:20px;font-weight:200;color:#aaa;margin-top:20px}.me__photo{animation:bounce 1s normal;margin-right:20px}.me__photo img{margin:0}.me__photo img:hover{animation:bounce 1s infinite}.me__photo__avatar{display:inline-block;width:110px;height:110px;border-radius:50%}.me__separator{width:60%;border-top:1px solid #eee}.me p a{font-weight:500}.me p{color:#aaa;font-weight:200;margin:0;padding:5px}.me p:last-child{margin-bottom:15px}@keyframes bounce{0%,20%,53%,80%,to{animation-timing-function:cubic-bezier(.215,.61,.355,1);transform:translateZ(0)}40%,43%{animation-timing-function:cubic-bezier(.755,.05,.855,.06);transform:translate3d(0,-30px,0)}70%{animation-timing-function:cubic-bezier(.755,.05,.855,.06);transform:translate3d(0,-15px,0)}90%{transform:translate3d(0,-4px,0)}}.markdown img{width:100%}.markdown h2{margin-top:30px;margin-bottom:30px}.markdown p,li,ul{color:#666;-webkit-font-smoothing:antialiased;text-rendering:optimizeLegibility;font-size:18px;line-height:1.4em;margin-top:20px;margin-bottom:20px}.markdown pre{display:block;background:#3f3f3f;color:#dcdcdc;overflow-y:hidden;margin-top:30px;margin-bottom:30px}.markdown pre code{background:none;border:none;border-radius:3px;display:inline-block;overflow:inherit;padding:1.58333rem;white-space:inherit;word-wrap:normal}code{white-space:pre;white-space:pre-wrap;white-space:pre-line;white-space:-pre-wrap;white-space:-o-pre-wrap;white-space:-moz-pre-wrap;white-space:-hp-pre-wrap;word-wrap:break-word;font-size:85%;background-color:rgba(0,0,0,.04);border-radius:3px;display:inline;font-family:Inconsolata,monospace,serif;max-width:100%;overflow:auto;padding:0 .1625rem}.clojure .hljs-attribute,.css .hljs-class,.css .hljs-id,.hljs-keyword,.hljs-request,.hljs-status,.hljs-tag,.lisp .hljs-title,.nginx .hljs-title{color:#e3ceab}.django .hljs-filter .hljs-argument,.django .hljs-template_tag,.django .hljs-variable{color:#dcdcdc}.hljs-date,.hljs-number{color:#8cd0d3}.apache .hljs-sqbracket,.dos .hljs-envvar,.dos .hljs-stream,.hljs-variable{color:#efdcbc}.diff .hljs-change,.dos .hljs-flow,.hljs-literal,.python .exception,.python .hljs-built_in,.tex .hljs-special{color:#efefaf}.diff .hljs-chunk,.hljs-subst{color:#8f8f8f}.apache .hljs-tag,.diff .hljs-header,.dos .hljs-keyword,.haskell .hljs-type,.hljs-prompt,.hljs-title,.nginx .hljs-built_in,.python .hljs-decorator,.ruby .hljs-class .hljs-parent,.tex .hljs-command{color:#efef8f}.dos .hljs-winutils,.ruby .hljs-string,.ruby .hljs-symbol,.ruby .hljs-symbol .hljs-string{color:#dca3a3}.apache .hljs-cbracket,.coffeescript .hljs-attribute,.css .hljs-rules .hljs-value,.diff .hljs-deletion,.hljs-attr_selector,.hljs-built_in,.hljs-javadoc,.hljs-pragma,.hljs-preprocessor,.hljs-pseudo,.hljs-string,.hljs-tag .hljs-value,.smalltalk .hljs-array,.smalltalk .hljs-class,.smalltalk .hljs-localvars,.sql .hljs-aggregate,.tex .hljs-formula{color:#cc9393}.diff .hljs-addition,.hljs-comment,.hljs-doctype,.hljs-pi,.hljs-shebang,.hljs-template_comment,.java .hljs-annotation{color:#7f9f7f}.coffeescript .javascript,.javascript .xml,.tex .hljs-formula,.xml .css,.xml .hljs-cdata,.xml .javascript,.xml .vbscript{opacity:.5}p.post__author{font-size:14px;text-align:center;margin:0 auto;margin-bottom:40px;margin-top:20px;color:#aaa}.post__title{text-align:center;font-weight:200;color:#222;margin-top:0}p.post__date{font-size:14px;text-transform:uppercase;color:#aaa;text-align:center;margin:0 auto}body{margin:0;border-top:8px solid #d64292;font-family:Raleway,sans-serif}.wrapper{padding:60px 40px 0;max-width:700px;margin:0 auto}.love{font-weight:200}.load-more,.love{padding-bottom:80px;padding-top:60px;color:#aaa;text-align:center;margin:0 auto}.load-more{font-size:16px;font-weight:500}.load-more button{font-size:16px;font-weight:700;color:#d64292;background:none;border:none;margin:0;padding:0;cursor:pointer}.load-more button:hover{text-decoration:underline}.purple,a{color:#d64292;text-decoration:none}hr{margin-top:40px;margin-bottom:40px;width:80%;border:1px solid #eee}.post-list{padding:10px}.post-list__item{text-decoration:none;display:block;padding-left:20px;border-left:4px solid #aaa;min-height:100px;margin-bottom:80px;transition:all .4s ease-out}.post-list__item-enter{opacity:.01}.post-list__item-enter-active{opacity:1}.post-list__item:last-child{margin-bottom:0}.post-list__item:hover{border-left:4px solid #d64292}.post-list__item__header{margin-top:26px;display:-ms-flexbox;display:flex}.post-list__item__header__title{-ms-flex:4;flex:4;font-size:20px;color:#222;margin-top:0;margin-bottom:8px}.post-list__item__header__date{-ms-flex:1;flex:1;color:#aaa;text-align:right}.post-list__item__desc{color:#aaa;font-size:18px;margin-top:0}.talk-list{max-width:600px;margin:0 auto}.talk-list__talk{border-radius:2px;margin-top:40px;display:-ms-flexbox;display:flex;box-shadow:0 1px 3px rgba(0,0,0,.12),0 1px 2px rgba(0,0,0,.24);transition:all .3s cubic-bezier(.25,.8,.25,1)}.talk-list__talk:hover{box-shadow:0 14px 28px rgba(0,0,0,.25),0 10px 10px rgba(0,0,0,.22)}.talk-list__talk__map{-ms-flex:1;flex:1}.talk-list__talk__content{padding:20px;-ms-flex:3;flex:3}.talk-list__talk__content p{margin-top:0;margin-bottom:15px}.talk-list__talk__content__name{font-weight:200;font-size:24px}.talk-list__talk__content__name--cancelled{text-decoration:line-through}.cancelled{font-weight:200;font-size:24px;color:red;text-decoration:none}.talk-list__talk__content__event{font-weight:200;color:#222;font-size:18px}.light{color:#aaa}</style></head><body class="landing-page"><div id="react-mount"><div style="max-width:960px;margin-left:auto;margin-right:auto;" data-reactroot="" data-reactid="1" data-react-checksum="-830752208"><div class="wrapper markdown" data-reactid="2"><!-- react-empty: 3 --><h1 class="post__title" data-reactid="4">Authentication in Relay Applications using Rails and GraphQL</h1><p class="post__date" data-reactid="5">March 6, 2016</p><p class="post__author" data-reactid="6"><!-- react-text: 7 -->by <!-- /react-text --><a href="/" data-reactid="8">Marc-Andre Giroux</a></p><div data-reactid="9"><meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@__xuorig__">
<meta name="twitter:creator" content="@__xuorig__">
<meta name="twitter:title" content="Authentication in Relay Applications using Rails and GraphQL">
<meta name="twitter:description" content="Using an Authorization Token to enable authentication in Relay applications using Rails with Devise and GraphQL">
<meta name="twitter:image" content="https://cloud.githubusercontent.com/assets/2231765/9094460/cb43861e-3b66-11e5-9fbf-71066ff3ab13.png">
<p>Most of apps today have users and require some form of Auth. It can be tricky to implement it in a Relay app because we don’t have explicit control on what we send to the server.</p>
<p>Here’s the way I’ve been doing it in my project, this solution assumes that you’re using <a href="https://github.com/plataformatec/devise">Devise</a> for authentication in your Rails app.</p>
<h3>Authorization Token</h3>
<p>The way I’ve implemented Authentication in my Relay app is by using an Authorization Token in the request headers.</p>
<p>First thing we’re going to do is modify the <code>DefaultNetworkLayer</code> to always send the <code>Authorization</code> header when we have it. We’re going to hold the token in <code>localStorage</code>.</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> token = localStorage.getItem(<span class="hljs-string">'auth_token'</span>);
<span class="hljs-keyword">const</span> headers = { <span class="hljs-attr">Authorization</span>: token }

Relay.injectNetworkLayer(
  <span class="hljs-keyword">new</span> Relay.DefaultNetworkLayer(<span class="hljs-string">'http://localhost:3000/your_GraphQL_endpoint'</span>, {
    <span class="hljs-attr">headers</span>: headers
  })
);
</code></pre>
<p>Now everytime Relay fetches data, our token will be sent as a header so we can auth server side.</p>
<h3>Handling the token server side</h3>
<h4>Authorization Token</h4>
<p>If we want to use an <code>auth_token</code> to identify our users, we’ll need that in our database. Let’s create a migration to add the column:</p>
<pre><code class="language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AddAccessTokenToUser</span> &lt; ActiveRecord::Migration</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">change</span></span>
    add_column <span class="hljs-symbol">:users</span>, <span class="hljs-symbol">:access_token</span>, <span class="hljs-symbol">:string</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>Alright, now that we have that column, we can actually use it. We want every user to have an <code>auth_token</code>. What we can do is generate one everytime we create a new user, like this:</p>
<pre><code class="language-ruby">  <span class="hljs-comment"># models/user.rb</span>
  after_create <span class="hljs-symbol">:update_access_token!</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">update_access_token!</span></span>
    access_token = <span class="hljs-string">"<span class="hljs-subst">#{<span class="hljs-keyword">self</span>.id}</span>:<span class="hljs-subst">#{Devise.friendly_token}</span>"</span>
    save!
  <span class="hljs-keyword">end</span>
</code></pre>
<p>A note here on how we generate that token. I’ve taken this idea from a great gist made by Jose Valim: <a href="https://gist.github.com/josevalim/fb706b1e933ef01e4fb6">https://gist.github.com/josevalim/fb706b1e933ef01e4fb6</a></p>
<p>We could’ve used only <code>Devise.friendly_token</code> for the token, and then find the user by this token everytime we want to retrieve it, but it’s not ideal for two main reasons: First, using <code>find_by(access_token: token)</code> is way slower that using the primary key like what we’re going to do here. Second, searching for the token itself is vulnerable to timing attacks. Here is a great blog post about that type of attack: <a href="https://codahale.com/a-lesson-in-timing-attacks/">https://codahale.com/a-lesson-in-timing-attacks/</a></p>
<p>Keep in mind that using the id here is faster and avoids timing attacks but I still would not use that in production. You should probably encrypt the id instead of having that plain text in our token, since it’s very obvious what it is in that case.</p>
<h4>Authenticate using the token</h4>
<p>The plan here is to be able to do <code>before_action :authenticate_user_from_token!</code> in our <code>GraphQL_controller</code>.</p>
<p>So lets define this method:</p>
<pre><code class="language-ruby">  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">authenticate_user_from_token!</span></span>
    auth_token = request.headers[<span class="hljs-string">'Authorization'</span>]
    <span class="hljs-keyword">return</span> authentication_error <span class="hljs-keyword">unless</span> auth_token
    authenticate_with_auth_token auth_token
  <span class="hljs-keyword">end</span>
</code></pre>
<p>Fairly straight forward. We grab the token from the headers and return a <code>401</code> if it is not there.
If it is there, we’re going to call <code>authenticate_with_auth_token</code> with it.</p>
<pre><code class="language-ruby">  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">authenticate_with_auth_token</span><span class="hljs-params">(auth_token)</span></span>
    <span class="hljs-comment"># return if the token does not have the right format</span>
    <span class="hljs-keyword">return</span> authentication_error <span class="hljs-keyword">unless</span> auth_token.<span class="hljs-keyword">include</span>?(<span class="hljs-string">':'</span>)

    <span class="hljs-comment"># Find the user by splitting the token and finding by id</span>
    <span class="hljs-comment"># Again, not the most secure way to do it, but works as an example.</span>
    user_id = auth_token.split(<span class="hljs-string">':'</span>).first
    user = User.where(<span class="hljs-symbol">id:</span> user_id).first

    <span class="hljs-comment"># Use secure_compare to mitigate timing atttacks</span>
    <span class="hljs-keyword">if</span> user &amp;&amp; Devise.secure_compare(user.access_token, auth_token)
      sign_in user, <span class="hljs-symbol">store:</span> <span class="hljs-literal">false</span>
    <span class="hljs-keyword">else</span>
      authentication_error
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">end</span>
</code></pre>
<p>We should be all set to start authenticating our users! Let’s see how we can use this.
Here’s an example of how you could handle GraphQL queries using the <code>GraphQL-ruby</code> gem.</p>
<pre><code class="language-ruby">  <span class="hljs-comment"># controllers/GraphQL_controller.rb</span>
  before_action <span class="hljs-symbol">:authenticate_user_from_token!</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create</span></span>
    query_string = params[<span class="hljs-symbol">:query</span>]
    query_variables = params[<span class="hljs-symbol">:variables</span>] <span class="hljs-params">||</span> {}
    result = YourSchema.execute(
      query_string,
      <span class="hljs-symbol">variables:</span> query_variables,
      <span class="hljs-symbol">context:</span> {<span class="hljs-symbol">current_user:</span> current_user}, <span class="hljs-comment"># Add the current_user into the query context</span>
    )
    render <span class="hljs-symbol">json:</span> result
  <span class="hljs-keyword">end</span>
</code></pre>
<p><code>authenticate_user_from_token!</code> sets our current_user correctly if the token matches
a user, or will fail with a <code>401</code> if it cannot.</p>
<p>We can now use current_user anywhere in the query execution. We can simply have a <code>currentUser</code>
field on our <code>QueryRoot</code>, that our Relay app fetches.</p>
<pre><code class="language-ruby">  field <span class="hljs-symbol">:currentUser</span> <span class="hljs-keyword">do</span>
    type UserType
    resolve -&gt; (obj, args, ctx) {
      ctx[<span class="hljs-symbol">:current_user</span>]
    }
  <span class="hljs-keyword">end</span>
</code></pre>
<p>You can then easily access the <code>currentUser</code> in your Relay app by including it in your fragments.</p>
<h4>Signing in users</h4>
<p>Now that we can authenticate users with their auth_token, it would be fun to actually get that <code>auth_token</code> when we don’t have it in the first place, aka log in a user.</p>
<p>Turns out we can actually use a Relay Mutation for that purpose. Take a look at this mutation definition:</p>
<pre><code class="language-ruby">SignInMutation = GraphQL::Relay::Mutation.define <span class="hljs-keyword">do</span>
  name <span class="hljs-string">"SignIn"</span>
  input_field <span class="hljs-symbol">:email</span>, !types.String
  input_field <span class="hljs-symbol">:password</span>, !types.String

  return_field <span class="hljs-symbol">:access_token</span>, types.String

  resolve -&gt; (args, ctx) {
    @user = User.find_for_database_authentication(<span class="hljs-symbol">email:</span> args[<span class="hljs-symbol">:email</span>])
    access_token = <span class="hljs-keyword">if</span> @user.valid_password?(args[<span class="hljs-symbol">:password</span>])
      @user.access_token
    <span class="hljs-keyword">end</span>
    { <span class="hljs-symbol">access_token:</span> access_token }
  }
<span class="hljs-keyword">end</span>
</code></pre>
<p>The mutation is pretty straight forward too. We find the user by his email and validate the password passed in the arguments. If we successfuly authenticate the user, we can return his <code>access_token</code>!</p>
<p>On the Relay side, simply call the mutation with the <code>email</code> and <code>password</code> values coming from your sign in form, and set your local storage key with the <code>access_token</code> from the response.</p>
<p>Calling the mutation:</p>
<pre><code class="language-javascript">  <span class="hljs-keyword">let</span> onFailure = <span class="hljs-function">(<span class="hljs-params">transaction</span>) =&gt;</span> {
    <span class="hljs-keyword">var</span> error = transaction.getError() || <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Mutation failed.'</span>);
    <span class="hljs-built_in">console</span>.error(error);
  };

  <span class="hljs-keyword">let</span> onSuccess = <span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> access_token = response.signin.access_token;
    localStorage.setItem(<span class="hljs-string">'access_token'</span>, access_token);
    <span class="hljs-built_in">window</span>.location = <span class="hljs-string">'/'</span>;
  }

  Relay.Store.update(<span class="hljs-keyword">new</span> SignInMutation({
    <span class="hljs-attr">email</span>: email,
    <span class="hljs-attr">password</span>: password
  }), {onFailure, onSuccess});
</code></pre>
<p>The mutation itself (Notice the <code>REQUIRED_CHILDREN</code> config, which lets you force fragments to be included in the query):</p>
<pre><code class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SignInMutation</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Relay</span>.<span class="hljs-title">Mutation</span> </span>{
  getMutation() {
    <span class="hljs-keyword">return</span> Relay.QL<span class="hljs-string">`mutation {
      signin
    }`</span>;
  }

  getVariables() {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">email</span>: <span class="hljs-keyword">this</span>.props.email,
      <span class="hljs-attr">password</span>: <span class="hljs-keyword">this</span>.props.password,
    };
  }

  getFatQuery() {
    <span class="hljs-keyword">return</span> Relay.QL<span class="hljs-string">`
      fragment on SignInPayload {
        access_token
      }
    `</span>;
  }

  getConfigs() {
      <span class="hljs-keyword">return</span> [{
        <span class="hljs-attr">type</span>: <span class="hljs-string">'REQUIRED_CHILDREN'</span>,
        <span class="hljs-comment">// Forces these fragments to be included in the query</span>
        children: [Relay.QL<span class="hljs-string">`
          fragment on SignInPayload {
            access_token
          }
        `</span>],
      }];
    }
}
</code></pre>
<p>If the mutation is a success, and your <code>access_token</code> is successfuly set in localStorage, your next queries will have the correct <code>Authorization</code> header, making the currentUser available in your queries!</p>
<p>Hope this will help some of you, I’ve seen a lot of different ways of handling Authentication in GraphQL/Relay apps, so let me know if you have any other ways of doing it!</p>
<p>You can find me on Twitter <a href="https://twitter.com/__xuorig__">@__xuorig__</a> or <a href="http://github.com/xuorig">Github</a></p>
</div><p style="text-align:center;font-weight:bold;margin-top:30px;" data-reactid="10"><!-- react-text: 11 -->Go back to <!-- /react-text --><a href="/" data-reactid="12">Recent Posts</a><!-- react-text: 13 --> ✍️<!-- /react-text --></p><hr data-reactid="14"/><div style="margin-bottom:30px;" data-reactid="15"><h6 data-reactid="16">READ THIS NEXT:</h6><h3 data-reactid="17"><a href="/2016/implementing-the-relay-spec-for-a-graphql-server/" data-reactid="18">Implementing the Relay spec in a GraphQL server</a></h3><p data-reactid="19">





I’ve seen some confusion on Relay and GraphQL lately. GraphQL is so often used with Relay that I think sometimes we forget what a GraphQL server is, and what Relay adds on top of it. The goal of...</p></div><section class="disqus" data-reactid="20"><div id="disqus_thread" data-reactid="21"></div><script type="text/javascript" data-reactid="22"></script></section></div><span style="display:block;clear:both;" data-reactid="23"> </span></div></div><script src="/bundle.js?t=1479676918990"></script><script>
            (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
            })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

            ga('create', 'UA-69973242-1', 'auto');
            ga('send', 'pageview');
          </script></body></html>